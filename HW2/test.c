#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorB,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
void moveForwards()
{
	motor[rightMotor] = 10;
	motor[leftMotor] = 10;
}

void nudgeLeft()
{
	motor[rightMotor] = 7;
	motor[leftMotor] = -7;
	wait1Msec(500);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void nudgeRight()
{
	motor[rightMotor] = -7;
	motor[leftMotor] = 7;
	wait1Msec(500);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void turnLeft()
{
	motor[rightMotor] = 10;
	motor[leftMotor] = 0;
	wait1Msec(3750);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void turnRight()
{
	motor[rightMotor] = 0;
	motor[leftMotor] = 10;
	wait1Msec(3750);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void reverseTurnLeft()
{
	motor[rightMotor] = -10;
	motor[leftMotor] = 0;
	wait1Msec(3750);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void reverseTurnRight()
{
	motor[rightMotor] = 0;
	motor[leftMotor] = -10;
	wait1Msec(3750);
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void stopMove()
{
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}



task main()
{
	//detecting the value of color of starting point for 1 sec
	int startingPointValue = SensorValue(lightSensor);
	wait1Msec(1000);

	//while the current color is within the range of starting point color, move forwards. And stop
	/*while(SensorValue(lightSensor) <= startingPointValue+2 && SensorValue(lightSensor) >= startingPointValue-2)
	{
		moveForwards();
	}*/
	moveForwards();
	wait1Msec(1000);

	//as soon as it reaches here, which means it's on the path, and we need to record the value of path color
	int pathValue = SensorValue(lightSensor);
	wait1Msec(1000);

	//Now we have value of staring point and path
	while(true)
	{
		//we reach the starting point again
		//if(SensorValue(lightSensor) <= startingPointValue + 1 && SensorValue(lightSensor) >= startingPointValue - 1)
		if(SensorValue(lightSensor) == startingPointValue)
		{
			stopMove();
			wait1Msec(1000);
			//if(SensorValue(lightSensor) <= startingPointValue + 1 && SensorValue(lightSensor) >= startingPointValue - 1)
			if(SensorValue(lightSensor) == startingPointValue)
			{
				stopMove();
				break;
			}
			else
				continue;
		}

		//if we are on the path, move forwards
		if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
		{
			moveForwards();
		}

		//if we need to make a 90 degree turn, we checks each side.
		//If there is a path, we continue move forwards.
		//If it's not a path, we reverse it and go to the other way.
		else
		{
			//1. Nudge left and check
			nudgeLeft();
			//a. If there is a path, continues
			if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
			{
				continue;
			}
			//b. If there is no path, correct course.
			nudgeRight();



			//2. Nudge right and check
			nudgeRight();
			//a. If there is a path, continues
			if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
			{
				continue;
			}
			//b. If there is no path, correct course.
			nudgeLeft();



			//3. turn left and check
			turnLeft();
			//a. if there is a path, continues
			if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
			{
				continue;
			}
			//b. if there is no path, reverseTurnLeft and turnRight and continue
			else
			{
				stopMove();
				wait1Msec(1000);

				//if(SensorValue(lightSensor) <= startingPointValue + 1 && SensorValue(lightSensor) >= startingPointValue - 1)
				if(SensorValue(lightSensor) == startingPointValue)
				{
					stopMove();
					break;
				}
				else
					continue;

				//1. Nudge left and check
				nudgeLeft();
				//a. If there is a path, continues
				if(SensorValue(lightSensor) <= pathValue+10 && SensorValue(lightSensor) >= pathValue-10)
				{
					continue;
				}
				//b. If there is no path, correct course.
				nudgeRight();

				//3. Nudge right and check
				nudgeRight();
				//a. If there is a path, continues
				if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
				{
					continue;
				}
				//b. If there is no path, correct course.
				nudgeLeft();

				reverseTurnLeft();




				turnRight();
				if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
				{
					continue;
				}
				else
					//1. Nudge right and check
					nudgeRight();
					//a. If there is a path, continues
					if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
					{
						continue;
					}

					//b. If there is no path, correct course.
					nudgeLeft();
					//1. Nudge right and check
					nudgeLeft();
					//a. If there is a path, continues
					if(SensorValue(lightSensor) <= pathValue+8 && SensorValue(lightSensor) >= pathValue-8)
					{
						continue;
					}

					//b. If there is no path, correct course.
					nudgeRight();

					//Course completed/failed
					reverseTurnRight();
					stopMove();
					break;
			}

		}
	}

}
